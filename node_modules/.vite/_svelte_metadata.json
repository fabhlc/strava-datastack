{"compilerOptions":{"css":"external","dev":true,"hydratable":true},"configFile":false,"extensions":[".svelte",".md"],"preprocess":[{"markup":"({ content: content, filename: filename })=>{\n        if (typeof filename === 'undefined') return;\n        if (!filename.endsWith('+page.md')) return;\n        return {\n            code: $e07c8d31339f08f2$var$injectPartials(content)\n        };\n    }","injectPartials":"function $e07c8d31339f08f2$var$injectPartials(originalString) {\n    const r = /\\{@partial\\s+\"(.*?)\"\\s*\\}/g;\n    for (const match of originalString.matchAll(r) ?? []){\n        const filename = match[1];\n        // There is an error with parcel that prevents the use of the \"path\" library.\n        const content = $773sa$readFileSync(`./partials/${filename}`).toString();\n        originalString = originalString.replace(match[0], content);\n    }\n    return originalString;\n}"},{"markup":"markup ({ content: content, filename: filename }) {\n        if (filename?.endsWith('.md')) {\n            if (!content.match(/\\<script(.*)\\>/)) {\n                const result = content + '\\n\\n<script context=\"module\"> </script>\\n\\n<script> </script>\\n\\n';\n                return {\n                    code: result\n                };\n            }\n            if (!content.match(/\\<script(.*)context\\=\\\"module\\\"(.*)\\>/)) {\n                const result = content + '\\n\\n<script context=\"module\"> </script>\\n\\n';\n                return {\n                    code: result\n                };\n            }\n            if (!content.match(/\\<script\\>/)) {\n                const result = content + '\\n\\n<script> </script>\\n\\n';\n                return {\n                    code: result\n                };\n            }\n        }\n    }"},{"markup":"markup ({ content: content, filename: filename }) {\n            if (filename?.endsWith('.md')) {\n                let fileQueries = $812958982b4444cc$require$extractQueries(content);\n                dynamicQueries[$812958982b4444cc$require$getRouteHash(filename)] = fileQueries.reduce((acc, q)=>{\n                    acc[q.id] = q;\n                    return acc;\n                }, /** @type {typeof dynamicQueries[string]} */ {});\n                const externalQueryViews = '\\n\\n\\n' + fileQueries.filter((q)=>!q.inline).map((q)=>{\n                    return $812958982b4444cc$require$highlighter(q.compiledQueryString, q.id.toLowerCase());\n                }).join('\\n');\n                // Page contains frontmatter\n                const frontmatter = $812958982b4444cc$require$containsFrontmatter(content);\n                if (frontmatter) {\n                    const contentWithoutFrontmatter = content.substring(frontmatter.length + 6);\n                    const output = `---\\n${frontmatter}\\n---` + externalQueryViews + contentWithoutFrontmatter;\n                    return {\n                        code: output\n                    };\n                }\n                return {\n                    code: externalQueryViews + content\n                };\n            }\n        }","script":"script ({ content: content, filename: filename, attributes: attributes }) {\n            if (filename?.endsWith('.md')) {\n                if (attributes.context !== 'module') {\n                    const duckdbQueries = dynamicQueries[$812958982b4444cc$require$getRouteHash(filename)];\n                    return {\n                        code: $812958982b4444cc$var$createDefaultProps(filename, componentDevelopmentMode, duckdbQueries) + content\n                    };\n                }\n            }\n        }"},{"name":"mdsvex","markup":"async ({ content: content, filename: filename })=>{\n            const extensionsParts = (extensions || [\n                extension\n            ]).map((ext)=>ext.split('.').pop());\n            if (!extensionsParts.includes(filename.split('.').pop())) return;\n            const parsed = await parser.process({\n                contents: content,\n                filename: filename\n            });\n            return {\n                code: parsed.contents,\n                data: parsed.data,\n                map: ''\n            };\n        }"},{"markup":"({ content: content, filename: filename })=>{\n            if (typeof filename === 'undefined') return;\n            if (!filename.endsWith('+page.md')) return;\n            if (!handleOgContent) handleOgContent = (parcelRequire(\"9FTVY\"));\n            return {\n                code: handleOgContent + content\n            };\n        }","script":"({ content: content, filename: filename, attributes: attributes })=>{\n            if (!filename?.endsWith('+page.md')) return;\n            if (attributes.context === 'module') {\n                if (!content.includes('export const metadata =')) // There is no frontmatter, and we want to make sure that it as at least defined.\n                // Technically this won't _break_ things, just spam the logs with a vite warning.\n                return {\n                    code: content + ';const metadata = undefined;'\n                };\n                else // exporting makes tailwind break HMR\n                return {\n                    code: content.replace('export const metadata =', 'const metadata =')\n                };\n            } else return {\n                code: 'import { addBasePath } from \"@evidence-dev/sdk/utils/svelte\";' + content\n            };\n        }"},{"markup":"async ({ content, filename }) => {\n\t\t\tif (filename?.endsWith('.svelte')) return; /* Don't autoimport into svelte files */\n\t\t\tconst components = await componentPlugins.catch((e) => {\n\t\t\t\tconsole.debug(e);\n\t\t\t\treturn false;\n\t\t\t});\n\t\t\tif (!components) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst { markup: autoimport_process_markup } = await autoImporter;\n\n\t\t\treturn autoimport_process_markup({ content, filename });\n\t\t}","style":"async () => {}","script":"async () => {}"},{"markup":"async ({ content, filename }) => {\n        if (transformers.replace) {\n            const transformed = await (0, exports.transform)('replace', transformers.replace, {\n                content,\n                markup: content,\n                filename,\n            });\n            content = transformed.code;\n        }\n        return (0, markup_1.transformMarkup)({ content, filename }, markupTransformer, {\n            // we only pass the markupTagName because the rest of options\n            // is fetched internally by the `markupTransformer`\n            markupTagName,\n        });\n    }","script":"async ({ content, attributes, markup: fullMarkup, filename, }) => {\n        const transformResult = await scriptTransformer({\n            content,\n            attributes,\n            markup: fullMarkup,\n            filename,\n        });\n        let { code, map, dependencies, diagnostics } = transformResult;\n        if (transformers.babel) {\n            const transformed = await (0, exports.transform)('babel', getTransformerOptions('babel'), { content: code, markup: fullMarkup, map, filename, attributes });\n            code = transformed.code;\n            map = transformed.map;\n            dependencies = (0, utils_1.concat)(dependencies, transformed.dependencies);\n            diagnostics = (0, utils_1.concat)(diagnostics, transformed.diagnostics);\n        }\n        return { code, map, dependencies, diagnostics };\n    }","style":"async ({ content, attributes, markup: fullMarkup, filename, }) => {\n        const transformResult = await cssTransformer({\n            content,\n            attributes,\n            markup: fullMarkup,\n            filename,\n        });\n        let { code, map, dependencies } = transformResult;\n        const hasPostcss = await (0, utils_1.hasDepInstalled)('postcss');\n        // istanbul ignore else\n        if (hasPostcss) {\n            if (transformers.postcss) {\n                const { alias, lang } = (0, language_1.getLanguage)(attributes);\n                const postcssOptions = getTransformerOptions('postcss', (0, language_1.isAliasOf)(alias, lang) ? alias : null, \n                // todo: this seems wrong and ugly\n                { ignoreAliasOverride: true });\n                const transformed = await (0, exports.transform)('postcss', postcssOptions, {\n                    content: code,\n                    markup: fullMarkup,\n                    map,\n                    filename,\n                    attributes,\n                });\n                code = transformed.code;\n                map = transformed.map;\n                dependencies = (0, utils_1.concat)(dependencies, transformed.dependencies);\n            }\n            const transformed = await (0, exports.transform)('globalStyle', getTransformerOptions('globalStyle'), { content: code, markup: fullMarkup, map, filename, attributes });\n            code = transformed.code;\n            map = transformed.map;\n        }\n        else if ('global' in attributes) {\n            console.warn(`[svelte-preprocess] 'global' attribute found, but 'postcss' is not installed. 'postcss' is used to walk through the CSS and transform any necessary selector.`);\n        }\n        return { code, map, dependencies };\n    }"},{"markup":"({ content, filename }) => {\n\t\tif (!filename?.endsWith('+page.md')) return;\n\t\tif (!cfg) {\n\t\t\tcfg = getEvidenceConfig();\n\t\t}\n\t\tlet r = content;\n\n\t\tconst regex = /(href|src)=['\"]?([^'\">= ]*)['\"]?/g;\n\t\tconst matches = content.matchAll(regex);\n\t\tfor (const match of matches) {\n\t\t\tconst originalContent = match[0];\n\t\t\tconst path = match[2];\n\t\t\tif (path) {\n\t\t\t\tconst newPath = addBasePath(path, cfg);\n\t\t\t\tr = r.replace(originalContent, originalContent.replace(path, newPath));\n\t\t\t}\n\t\t}\n\n\t\treturn { code: r };\n\t}"},{"script":"({ content, filename }) => {\n\t\tif (!filename) return;\n\n\t\tconst basename = path.basename(filename);\n\t\tif (basename.startsWith('+page.') || basename.startsWith('+layout.')) {\n\t\t\tconst match = content.match(options_regex);\n\t\t\tif (match) {\n\t\t\t\tconst fixed = basename.replace('.svelte', '(.server).js/ts');\n\n\t\t\t\tconst message =\n\t\t\t\t\t`\\n${colors.bold().red(path.relative('.', filename))}\\n` +\n\t\t\t\t\t`\\`${match[1]}\\` will be ignored — move it to ${fixed} instead. See https://svelte.dev/docs/kit/page-options for more information.`;\n\n\t\t\t\tif (!warned.has(message)) {\n\t\t\t\t\tconsole.log(message);\n\t\t\t\t\twarned.add(message);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}","markup":"({ content, filename }) => {\n\t\tif (!filename) return;\n\n\t\tconst basename = path.basename(filename);\n\t\tconst has_children =\n\t\t\tcontent.includes('<slot') || (isSvelte5Plus() && content.includes('{@render'));\n\n\t\tif (basename.startsWith('+layout.') && !has_children) {\n\t\t\tconst message =\n\t\t\t\t`\\n${colors.bold().red(path.relative('.', filename))}\\n` +\n\t\t\t\t`\\`<slot />\\`${isSvelte5Plus() ? ' or `{@render ...}` tag' : ''}` +\n\t\t\t\t' missing — inner content will not be rendered';\n\n\t\t\tif (!warned.has(message)) {\n\t\t\t\tconsole.log(message);\n\t\t\t\twarned.add(message);\n\t\t\t}\n\t\t}\n\t}"}]}