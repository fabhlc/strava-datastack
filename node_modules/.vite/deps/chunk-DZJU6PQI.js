import {
  readable,
  readonly,
  writable
} from "./chunk-2Q2OS3AX.js";
import {
  getAllContexts,
  getContext,
  get_store_value,
  setContext
} from "./chunk-SQSKWABO.js";

// ../../node_modules/@evidence-dev/sdk/src/utils/svelte/inputs.js
var InputStoreKey = Symbol("InputStore");
var isReadable = (v) => {
  if (typeof v !== "object") return false;
  if (v === null) return false;
  return "subscribe" in v;
};
var isWritable = (v) => {
  if (!isReadable(v)) return false;
  return "set" in v && "update" in v;
};
var ensureInputContext = (c) => {
  if (!isWritable(c)) {
    console.error({ InputStoreValue: c });
    throw new Error("InputStore must be a writable store");
  }
  if (!getAllContexts().has(InputStoreKey)) {
    setContext(InputStoreKey, c);
    return c;
  } else {
    const existingValue = getContext(InputStoreKey);
    existingValue.set(get_store_value(c));
    return existingValue;
  }
};
var getInputContext = () => {
  if (!getAllContexts().has(InputStoreKey)) {
    console.warn("InputStoreKey not found in context. Did you forget to call ensureInputContext?");
    return writable({});
  }
  return getContext(InputStoreKey);
};
var getReadonlyInputContext = () => {
  if (!getAllContexts().has(InputStoreKey)) {
    console.warn("InputStoreKey not found in context. Did you forget to call ensureInputContext?");
    return readable({});
  }
  const value = getContext(InputStoreKey);
  if (isReadable(value)) {
    return readonly(value);
  } else {
    throw new Error(`InputStoreKey is not a readable store: ${value}`);
  }
};
var getInputSetter = (inputKey, toggle, defaultSqlFragment) => {
  const inputs = getInputContext();
  let inputPath = Array.isArray(inputKey) ? inputKey : [inputKey];
  if (!inputPath.length) {
    return () => {
      console.warn(`Failed to update input: ${inputPath} is not a valid input path`);
    };
  }
  return (value, label, sqlFragment, additional) => {
    inputs.update(($inputs) => {
      let target = $inputs;
      let finalKey = inputPath.at(-1) ?? "";
      for (const p of inputPath.slice(0, -1)) {
        target = target[p];
      }
      if (!value && !label) {
        target[finalKey] = {
          toString() {
            return defaultSqlFragment;
          }
        };
        return $inputs;
      }
      const result = {
        ...additional,
        value,
        label,
        toString() {
          return sqlFragment;
        }
      };
      if (toggle && JSON.stringify(target[finalKey]) === JSON.stringify(result)) {
        target[finalKey] = {
          toString() {
            return defaultSqlFragment;
          }
        };
      } else {
        target[finalKey] = result;
      }
      return $inputs;
    });
  };
};

// ../../node_modules/@evidence-dev/sdk/src/utils/svelte/addBasePath.js
var addBasePath = (path, config2) => {
  if (path instanceof String) path = path.toString();
  if (typeof path !== "string") return path;
  if (path.startsWith("http")) return path;
  if (path.startsWith("#")) return path;
  if (/^[^/]*:/.test(path)) return path;
  let basePath = config2.deployment.basePath;
  if (basePath) {
    if (!(basePath == null ? void 0 : basePath.startsWith("/"))) {
      basePath = `/${basePath}`;
    }
    if (basePath.endsWith("/")) {
      basePath = basePath.slice(0, -1);
    }
    if (path.startsWith(basePath)) return path;
    if (!path.startsWith("/")) {
      path = `/${path}`;
    }
    return `${basePath}${path}`;
  } else {
    return path;
  }
};

// ../../node_modules/@evidence-dev/sdk/src/utils/svelte/index.js
import { config } from "$evidence/config";
var addBasePath2 = (path) => addBasePath(path, config);

export {
  InputStoreKey,
  isReadable,
  ensureInputContext,
  getInputContext,
  getReadonlyInputContext,
  getInputSetter,
  addBasePath2 as addBasePath
};
//# sourceMappingURL=chunk-DZJU6PQI.js.map
